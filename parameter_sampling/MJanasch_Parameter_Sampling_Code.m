% New function to sample the parameter space and calculate coefficients 
% adapted and modified from Murabito et al. 2014
% Markus Janasch, Ph.D. Student, KTH
% Created: 2017-09-27, last modified: 2017-09-27

function [DataOut] = MJanasch_Parameter_Sampling_Code(iterations,InputDataStructure,MetConcDataIn,MetNames,ModelType)
tic
% [CJ_rec,CS_rec,E_rec,MaxRealEigens,Parameters] = Sampling_code(M,Fluxes1,FullSto,RedSto,Link,seed)
%
% INPUT:
%
% * N       - Matlab structure containing the specifications of the model.
%             Such data structure is generated by the function
%             N = TranslateSBML(); N must be enriched with the cmetabolite
%             concentrations at steady-state.
%
% * Fluxes  - Vector containing the fluxes at theady state of the different
%             reactions in the model N. The entries in 'Fluxes' correspond
%             to the reactions in M, i.e. Fluxes(i) is the flux of the ith
%             reaction in N (N.reaction(i))
%
% * SFull   - Full stoichiometry matrix
%
% * SRed    - Reduced stoichiometry matrix
% 
% * L       - Link matrix
% 
% * seed    - (optional) seed to initialize the random number generator
%
%
% OUTPUTS:
%
% * CJ_rec  - 3-dimensional matrix of the scaled flux control coefficients
%             for all parameter sets resulting in the steady-state being
%             stable. CJ_rec(i,j,z) is the control exerted by enzyme j upon
%             flux i given the parameters sampled at iterazion z.
%
% * CS_rec  - 3-dimensional matrix of the scaled concentration control
%             coefficients for all parameter sets resulting in the steady-
%             state being stable.
%
% * E_rec   - 3-dimensional matrix of the scaled elasticity coefficients
%             for all parameter sets resulting in the steady-state being
%             stable.
%
% * MaxRealEigens -
%             Vector containing the maximal real part of the eigenvalues
%             for each parameter sampling iteration.
%
% * Parameters - 
%             2-dimensional matrix containing all the system's parameters
%             for each sampling iteration. Each row correspond to a
%             sampling iteration and each column to a parameter.
%


clc;

%--------------- VARIABLES DECLARATION ---------------%

% iterations = 1000; % No. of sampling iterations (Orig iterations=20000)
% Here as input to the function, defined in command line

load(InputDataStructure); % Load N, Fluxes, SFull, SRed and L

for h = 1:length(N.species)
    if ~strncmp(N.species(h).name,'BioM',4) && ~strncmp(N.species(h).name,'PPool',5)
        MetIndex=FindIndex(MetNames,N.species(h).name);
        N.species(h).initialConcentration = MetConcDataIn(1,MetIndex);
    elseif strncmp(N.species(h).name,'PPool',5)
        MetIndex_PHI=FindIndex(MetNames,'PHI');
        N.species(h).initialConcentration = MetConcDataIn(1,MetIndex_PHI)*1.1;
    else
        N.species(h).initialConcentration = 0;
    end
end



nOfSS = 0; % No. of sampling iterations resulting in stable steady-states

F1 = 0.01; % Multiplicative factor defining the lower bound of the sampling intervals
F2 = 100;  % Multiplicative factor defining the upper bound of the sampling intervals

MaxRealEigens = zeros(iterations,1); % At iteration i, the maximal real
                                     % part of the eigenvalues is stored in
                                     % MaxRealEigens(i,1)
                                     
[m,n] = size(SFull); % Size of the full stoichiometric matrix
[m1,n] = size(SRed); % Size of the reduced stoichiometric matrix

CS = zeros(m,n); % Concentration Control Coefficients
CJ = zeros(n,n); % Flux Control Coefficients
                 
CJ_rec = zeros(n,n,iterations); % Flux control coefficients of stable systems
CS_rec = zeros(m,n,iterations); % Concentration control coefficients of stable systems
E_rec = zeros(n,m,iterations);  % Elasticity coefficients of stable systems
dfodc = {};
dfodc = zeros(n,m); % Matrix containing the numeric value of the derivative
                    % of the fluxes with respect to the metabolite
                    % concentrations.

RedJac1 = zeros(m1,m1); % Reduced Jacobian Matrix

R = {N.reaction.name}; % Names of the reactions
S = {N.species.id};    % Names of the metabolites



ID = eye(n);  % Unitary matrix with n. of columns/rows = n. of reactions
%% Replace GetAllParameters
[ParID,ParVal] = GetAllParameters(N);




Parameters = zeros(iterations,length(ParID)); % At iteration i, all the
                                              % parameters (sampled and 
                                              % const) are stored in row i
                                              % of this matrix.

StabilityIndicator = zeros(iterations,1);


%% Set initial Concentrations
Conc = [];                                    % Initialize concentration 
                                              % vector
for i=1:length(N.species)
    if ~N.species(i).boundaryCondition        % if the boundary condition=0
                                              % (=internal metabolite, = no
                                              % constant set concentration)
        Conc(i) = N.species(i).initialConcentration; % fill in initial conc
    end
end
Conc = Conc(:);                                % align all columns after 
                                               % each other (example:
                                               % 6x5-matrix to 30x1 matrix)
Fluxes = Fluxes(:);                            % align all columns


%-- COMPUTE THE NORMALIZATION MATRICES FOR CJ and CS --%
nrmlz1 = compute_normalization_matrix(Fluxes);% create rxr matrix of fluxes
                                               % normalized by fluxes
                                               % every flux normalized/divided
                                               % by every flux
nrmlz3 = compute_normalization_matrix2(Fluxes,Conc);
                                               % create rxr matrix of conc
                                               % normalized by fluxes

%-- COMPUTE THE SAMPLING INTERVAL OF EACH PARAMETER --%
%-- ACCORDING TO THE CONCENTRATIONS OF METABOLITES  --%
[ParValMin,ParValMax,vmax_K_indeces] = compParInt(N,F1,F2);

% Really necessary?
eval('default = 1;');       % Express that the default value for almost all
                            % parameters (except Ki, Ka, Keq)

                         % start timer

if ~exist('seed','var'); seed = 'shuffle'; end; % if no seed defined, set it to 'shuffle', dependend on current time
rng(seed);                              % define control of random number 
                                        % generater

for c = 1:iterations                    % for every interation
   
    %-- SAMPLE PARAMETERS --%
    for p=1:length(ParID)               % for every parameter
        ParAux = log(ParValMin(p)) + rand(1)*(log(ParValMax(p)) - log(ParValMin(p)));
                                        % create a value, can be negative
            
        ParAux = exp(ParAux);           % e^alue, now always positive!
                                               
        Parameters(c,p) = ParAux;       % save the p-th parameter for the 
                                        % c-th iteration in matrix as well
    end

    %-------------------------------------------------------------
    %-- Calculating Vmax & K and DFODC --%
    
    if strncmp(ModelType,'CBB',3)
        [dfodc,Parameters(c,:)] = MJanasch_Calculate_DFODC(N,Parameters(c,:),vmax_K_indeces,Fluxes,SFull);
    elseif strncmp(ModelType,'XFPK',4)
        [dfodc,Parameters(c,:)] = MJanasch_Calculate_DFODC_XFPK(N,Parameters(c,:),vmax_K_indeces,Fluxes,SFull);
    elseif strncmp(ModelType,'XFPK_REG',8)
        [dfodc,Parameters(c,:)] = MJanasch_Calculate_DFODC_XFPK_REG(N,Parameters(c,:),vmax_K_indeces,Fluxes,SFull);
    else
        fprintf('%s\n', 'ModelType not specified. Choose either CBB or XFPK or XFPK_REG');
    end
    %-------------------------------------------------------%
  
    
    % ---- COMPUTING THE REDUCED JACOBIANS ----%
    RedJac1(:,:) = SRed(:,:)*dfodc(:,:)*L(:,:);
    
    %---- COMPUTING THE EIGENVALUES ----%
    eigenvalues = eig(RedJac1);             % Calculate eigenvalues
    MaxRealEigen = max(real(eigenvalues));  % Find the maximum of the real
                                            % part of the eigenvalues
    MaxRealEigens(c,1) = MaxRealEigen;      % Save these for c-th iteration
                                            % in matrix
    
    %---- Save numerical values for derivative matrix  ----%
        dfodc_rec(:,:,c) = dfodc;
                                                                                    
    %---- CHECKING FOR STABILITY ----%
    ok = 1;                                 % Initialize binary checking-
                                            % variable
    if(MaxRealEigen >= 0)                   % If the maximum of the real 
                                            % part of the eigenvalues is
                                            % larger or equal to 0
        ok = 0;                             % set checking-variable to 0
    end
    
    if(ok == 1)                             % If the checking-variable = 1
        StabilityIndicator(c) = 1;
        nOfSS = nOfSS + 1;                  % Increase number of stable SS
        
        %---- COMPUTING AND RECORDING ELASTICITY COEFFICIENTS ----%
        E_rec(:,:,nOfSS) = dfodc .* (nrmlz3(:,:))';
        
        %---- COMPUTING THE CONCENTRATION CONTROL COEFFICIENTS ----%
        CS(:,:) = -(L*(inv(RedJac1(:,:)))*SRed);

        %---- COMPUTING THE FLUX CONTROL COEFFICIENTS ----%
        CJ(:,:) = (ID + dfodc(:,:)*CS(:,:))./nrmlz1(:,:);
        CJ_rec(:,:,nOfSS) = CJ; 
        CS_rec(:,:,nOfSS) = CS./nrmlz3;   
    end
% %% Output every 10 iterations about the % of stable steady states
%     ratio = (nOfSS/c)*100;
%     if(~mod(c,10) || c == iterations)
%     	fprintf('%d%s%d%s%6.2f%s\n',nOfSS,' -> ',c,' (',ratio,'%)');
%     end

end



CJ_rec(:,:,(nOfSS+1):end) = [];
CS_rec(:,:,(nOfSS+1):end) = [];
E_rec(:,:,(nOfSS+1):end) = [];

%% Define output-data
DataOut.CJ_rec              = CJ_rec;
DataOut.CS_rec              = CS_rec;
DataOut.E_rec               = E_rec;
DataOut.Parameters          = Parameters;
for q=1:length(N.species)
    DataOut.Conc(q)               = N.species(q).initialConcentration;
end
DataOut.dfodc               = dfodc_rec;
DataOut.ParID               = ParID;
DataOut.StabilityIndicator  = StabilityIndicator;
toc

%==========================================================================
%% Find indexes Function
function [n] = FindIndex(haystack, needle)
     n=find(ismember(haystack,needle));

%==========================================================================     
function nrmlz = compute_normalization_matrix(Fluxes)

nrmlz = Fluxes * ((1./Fluxes)');

%==========================================================================
function nrmlz = compute_normalization_matrix2(Fluxes,Conc)

nrmlz = Conc * ((1./Fluxes)');

%==========================================================================
function [ParValMin,ParValMax,vmax_K_indeces] = compParInt(N,F1,F2)

Conc = [];
S = {N.species.id};
for i=1:length(S)
    Conc(i) = N.species(i).initialConcentration;    % Get all initial conc.
end                                                 % not just internal

[ParID,ParVal] = GetAllParameters(N);   % Get all reaction parameters

ParValMin = ParVal;                     % Set parameter minimum bound to 
                                        % parameter value
ParValMax = ParVal;                     % Set parameter maximum bound to
                                        % parameter value

count=1;                                % initialize counting variable
for p = 1:length(ParID)                 % for every parameter
    
    par_aux = ParID{p};                 % for parameter p
    if(par_aux(end-1) == 'v')           % if it has a 'v' as second last 
                                        % character:
        par_aux2 = par_aux(3:end-2);    % save only name of metabolite or 'max' or 'eq' 
    else
        par_aux2 = par_aux(3:end-3);    % if v as third last, meaning two
                                        % digit number reactions, save also
                                        % only NAME or 'max' or 'eq'
    end
    
    if ((~strcmp(par_aux2,'eq')) && (~strcmp(par_aux2,'max')) && (~strcmp(par_aux2,'PPool'))) 
        % if parameter p is NOT an equilibrium constant or a Vmax value
                                                                

           for i=1:length(S)               % for every metabolite
               if(strcmp(par_aux2,S{i}))   % if the parameter belongs to 
                                            % that metabolite (Km or Ki or
                                            % Ka)
                   ParValMin(p) = Conc(i)*F1; % set lower bound with conc
                   ParValMax(p) = Conc(i)*F2; % set upper bound with conc
                   break;
               end
           end
        
    elseif (~strcmp(par_aux2,'eq'))     % if parameter is a Vmax, set all 
                                        % to 1 (should be already?),
                                        % supposingly following of 
                                        % normalization, max V set to 1
        ParValMin(p) = 1;
        ParValMax(p) = 1;    
        vmax_K_indeces(count) = p;        % get Vmax indeces back (lost in 
                                        % par_aux-definition in beginning
                                        % of this subfunction (which
                                        % position there are in "Parameter"
        count = count+1;      
    end
end
